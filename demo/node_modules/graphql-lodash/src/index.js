"use strict";
var language_1 = require('graphql/language');
var GraphQLError_1 = require('graphql/error/GraphQLError');
var getOperationAST_1 = require('graphql/utilities/getOperationAST');
var concatAST_1 = require('graphql/utilities/concatAST');
var buildASTSchema_1 = require('graphql/utilities/buildASTSchema');
var values_1 = require('graphql/execution/values');
var get_js_1 = require('lodash/get.js');
var set_js_1 = require('lodash/set.js');
var each_js_1 = require('lodash/each.js');
var keyBy_js_1 = require('lodash/keyBy.js');
var isEqual_js_1 = require('lodash/isEqual.js');
var transformations_1 = require('./transformations');
var lodash_idl_1 = require('./lodash_idl');
function graphqlLodash(query, operationName) {
    var pathToArgs = {};
    var queryAST = typeof query === 'string' ? language_1.parse(query) : query;
    traverseOperationFields(queryAST, operationName, function (node, resultPath) {
        var args = getLodashDirectiveArgs(node);
        if (args === null)
            return;
        // TODO: error if transformation applied on field that already
        // seen without any transformation
        var argsSetPath = resultPath.concat(['@_']);
        var previousArgsValue = get_js_1["default"](pathToArgs, argsSetPath, null);
        if (previousArgsValue !== null && !isEqual_js_1["default"](previousArgsValue, args))
            throw Error("Different \"@_\" args for the \"" + resultPath.join('.') + "\" path");
        set_js_1["default"](pathToArgs, argsSetPath, args);
    });
    var stripedQuery = stripQuery(queryAST);
    return {
        query: typeof query === 'string' ? language_1.print(stripedQuery) : stripedQuery,
        transform: function (data) { return applyLodashDirective(pathToArgs, data); }
    };
}
exports.graphqlLodash = graphqlLodash;
function getLodashDirectiveArgs(node) {
    var lodashNode = null;
    for (var _i = 0, _a = node.directives; _i < _a.length; _i++) {
        var directive = _a[_i];
        if (directive.name.value !== lodashDirectiveDef.name)
            continue;
        if (lodashNode)
            throw Error("Duplicating \"@_\" on the \"" + node.name.value + "\"");
        lodashNode = directive;
    }
    if (lodashNode === null)
        return null;
    var args = values_1.getArgumentValues(lodashDirectiveDef, lodashNode);
    return normalizeLodashArgs(lodashNode.arguments, args);
}
function normalizeLodashArgs(argNodes, args) {
    if (!argNodes)
        return args;
    //Restore order of arguments
    argNodes = keyBy_js_1["default"](argNodes, function (argNode) { return argNode.name.value; });
    var orderedArgs = {};
    each_js_1["default"](argNodes, function (node, name) {
        var argValue = args[name];
        if (node.value.kind === 'ObjectValue')
            orderedArgs[name] = normalizeLodashArgs(node.value.fields, argValue);
        else if (node.value.kind === 'ListValue') {
            var nodeValues = node.value.values;
            orderedArgs[name] = [];
            for (var i = 0; i < nodeValues.length; ++i)
                orderedArgs[name][i] = normalizeLodashArgs(nodeValues[i].fields, argValue[i]);
        }
        else if (node.value.kind === 'EnumValue' && node.value.value === 'none')
            orderedArgs[name] = undefined;
        else
            orderedArgs[name] = argValue;
    });
    return orderedArgs;
}
function applyLodashDirective(pathToArgs, data) {
    if (data === null)
        return null;
    var changedData = applyOnPath(data, pathToArgs);
    return applyLodashArgs([], changedData, pathToArgs['@_']);
}
function applyLodashArgs(path, object, args) {
    try {
        return transformations_1.applyTransformations(object, args);
    }
    catch (e) {
        // FIXME:
        console.log(path);
        throw e;
    }
}
function applyOnPath(result, pathToArgs) {
    var currentPath = [];
    return traverse(result, pathToArgs);
    function traverse(root, pathRoot) {
        var subKeys = Object.keys(pathRoot).filter(function (key) { return key != '@_'; });
        if (subKeys.length === 0) {
            return;
        }
        if (root == null)
            return null;
        if (Array.isArray(root))
            return root.map(function (item) { return traverse(item, pathRoot); });
        var changedObject = Object.assign({}, root);
        for (var _i = 0, subKeys_1 = subKeys; _i < subKeys_1.length; _i++) {
            var key = subKeys_1[_i];
            currentPath.push(key);
            var _a = pathRoot[key], test = _a.test, keyRoot = _a.keyRoot;
            var changedValue = traverse(root[key], pathRoot[key]);
            if (changedValue === null || changedValue === undefined)
                continue;
            var lodashArgs = pathRoot[key]['@_'];
            changedValue = applyLodashArgs(currentPath, changedValue, lodashArgs);
            changedObject[key] = changedValue;
            currentPath.pop();
        }
        return changedObject;
    }
}
function stripQuery(queryAST) {
    return language_1.visit(queryAST, (_a = {},
        _a[language_1.Kind.DIRECTIVE] = function (node) {
            if (node.name.value === '_')
                return null;
        },
        _a
    ));
    var _a;
}
exports.lodashDirectiveAST = language_1.parse(new language_1.Source(lodash_idl_1.lodashIDL, 'lodashIDL'));
var lodashDirectiveDef = getDirectivesFromAST(exports.lodashDirectiveAST)[0];
function getDirectivesFromAST(ast) {
    var dummyIDL = "\n    type Query {\n      dummy: String\n    }\n  ";
    var fullAST = concatAST_1.concatAST([ast, language_1.parse(dummyIDL)]);
    var schema = buildASTSchema_1.buildASTSchema(fullAST);
    schema.getTypeMap()['Path'].parseLiteral = (function (x) { return x.value; });
    schema.getTypeMap()['JSON'].parseLiteral = astToJSON;
    return schema.getDirectives();
}
// TODO: copy-pasted from JSON Faker move to graphql-js or separate lib
function astToJSON(ast) {
    switch (ast.kind) {
        case language_1.Kind.NULL:
            return null;
        case language_1.Kind.INT:
            return parseInt(ast.value, 10);
        case language_1.Kind.FLOAT:
            return parseFloat(ast.value);
        case language_1.Kind.STRING:
        case language_1.Kind.BOOLEAN:
            return ast.value;
        case language_1.Kind.LIST:
            return ast.values.map(astToJSON);
        case language_1.Kind.OBJECT:
            return ast.fields.reduce(function (object, _a) {
                var name = _a.name, value = _a.value;
                object[name.value] = astToJSON(value);
                return object;
            }, {});
    }
}
function traverseOperationFields(queryAST, operationName, cb) {
    var fragments = {};
    var operationAST = getOperationAST_1.getOperationAST(queryAST, operationName);
    if (!operationAST) {
        throw new GraphQLError_1.GraphQLError('Must provide operation name if query contains multiple operations.');
    }
    queryAST.definitions.forEach(function (definition) {
        if (definition.kind === language_1.Kind.FRAGMENT_DEFINITION)
            fragments[definition.name.value] = definition;
    });
    var resultPath = [];
    cb(operationAST, resultPath);
    traverse(operationAST);
    function traverse(root) {
        language_1.visit(root, {
            enter: function (node) {
                if (node.kind === language_1.Kind.FIELD)
                    resultPath.push((node.alias || node.name).value);
                if (node.kind === language_1.Kind.FRAGMENT_SPREAD) {
                    var fragmentName = node.name.value;
                    var fragment = fragments[fragmentName];
                    if (!fragment)
                        throw Error("Unknown fragment: " + fragmentName);
                    traverse(fragment);
                }
            },
            leave: function (node) {
                if (node.kind !== language_1.Kind.FIELD)
                    return;
                cb(node, resultPath);
                resultPath.pop();
            }
        });
    }
}
