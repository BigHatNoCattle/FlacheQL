"use strict";
var every_js_1 = require('lodash/every.js');
var some_js_1 = require('lodash/some.js');
var startsWith_js_1 = require('lodash/startsWith.js');
var endsWith_js_1 = require('lodash/endsWith.js');
var lt_js_1 = require('lodash/lt.js');
var lte_js_1 = require('lodash/lte.js');
var gt_js_1 = require('lodash/gt.js');
var gte_js_1 = require('lodash/gte.js');
var eq_js_1 = require('lodash/eq.js');
var map_js_1 = require('lodash/map.js');
var keyBy_js_1 = require('lodash/keyBy.js');
var chunk_js_1 = require('lodash/chunk.js');
var drop_js_1 = require('lodash/drop.js');
var dropRight_js_1 = require('lodash/dropRight.js');
var take_js_1 = require('lodash/take.js');
var takeRight_js_1 = require('lodash/takeRight.js');
var flattenDepth_js_1 = require('lodash/flattenDepth.js');
var fromPairs_js_1 = require('lodash/fromPairs.js');
var nth_js_1 = require('lodash/nth.js');
var reverse_js_1 = require('lodash/reverse.js');
var uniq_js_1 = require('lodash/uniq.js');
var uniqBy_js_1 = require('lodash/uniqBy.js');
var countBy_js_1 = require('lodash/countBy.js');
var filter_js_1 = require('lodash/filter.js');
var reject_js_1 = require('lodash/reject.js');
var groupBy_js_1 = require('lodash/groupBy.js');
var sortBy_js_1 = require('lodash/sortBy.js');
var minBy_js_1 = require('lodash/minBy.js');
var maxBy_js_1 = require('lodash/maxBy.js');
var meanBy_js_1 = require('lodash/meanBy.js');
var sumBy_js_1 = require('lodash/sumBy.js');
var join_js_1 = require('lodash/join.js');
var get_js_1 = require('lodash/get.js');
var mapValues_js_1 = require('lodash/mapValues.js');
var at_js_1 = require('lodash/at.js');
var toPairs_js_1 = require('lodash/toPairs.js');
var invert_js_1 = require('lodash/invert.js');
var invertBy_js_1 = require('lodash/invertBy.js');
var keys_js_1 = require('lodash/keys.js');
var values_js_1 = require('lodash/values.js');
var transformations = {
    Array: {
        each: function (array, arg) {
            return map_js_1["default"](array, function (item) { return applyTransformations(item, arg); });
        },
        map: map_js_1["default"],
        keyBy: keyBy_js_1["default"],
        chunk: chunk_js_1["default"],
        drop: drop_js_1["default"],
        dropRight: dropRight_js_1["default"],
        take: take_js_1["default"],
        takeRight: takeRight_js_1["default"],
        flattenDepth: flattenDepth_js_1["default"],
        fromPairs: fromPairs_js_1["default"],
        nth: nth_js_1["default"],
        reverse: reverse_js_1["default"],
        uniq: uniq_js_1["default"],
        uniqBy: uniqBy_js_1["default"],
        countBy: countBy_js_1["default"],
        filter: filter_js_1["default"],
        reject: reject_js_1["default"],
        filterIf: function (array, arg) {
            return filter_js_1["default"](array, function (item) { return applyTransformations(item, arg); });
        },
        rejectIf: function (array, arg) {
            return reject_js_1["default"](array, function (item) { return applyTransformations(item, arg); });
        },
        groupBy: groupBy_js_1["default"],
        sortBy: sortBy_js_1["default"],
        minBy: minBy_js_1["default"],
        maxBy: maxBy_js_1["default"],
        meanBy: meanBy_js_1["default"],
        sumBy: sumBy_js_1["default"],
        join: join_js_1["default"]
    },
    Object: {
        get: get_js_1["default"],
        mapValues: mapValues_js_1["default"],
        at: at_js_1["default"],
        toPairs: toPairs_js_1["default"],
        invert: invert_js_1["default"],
        invertBy: invertBy_js_1["default"],
        keys: keys_js_1["default"],
        values: values_js_1["default"]
    },
    Number: {
        lt: lt_js_1["default"],
        lte: lte_js_1["default"],
        gt: gt_js_1["default"],
        gte: gte_js_1["default"],
        eq: eq_js_1["default"]
    },
    String: {
        startsWith: startsWith_js_1["default"],
        endsWith: endsWith_js_1["default"]
    }
};
var opToExpectedType = {};
for (var type in transformations)
    for (var name_1 in transformations[type])
        opToExpectedType[name_1] = type;
function applyTransformations(object, args) {
    if (!args)
        return object;
    for (var op in args) {
        if (object === null)
            break;
        var arg = args[op];
        if (op === 'and') {
            object = every_js_1["default"](arg, function (predicateArgs) { return applyTransformations(object, predicateArgs); });
            continue;
        }
        if (op === 'or') {
            object = some_js_1["default"](arg, function (predicateArgs) { return applyTransformations(object, predicateArgs); });
            continue;
        }
        var expectedType = opToExpectedType[op];
        var type = object.constructor && object.constructor.name;
        // handle objects created with Object.create(null)
        if (!type && (typeof object === 'object'))
            type = 'Object';
        if (expectedType !== type)
            throw Error("\"" + op + "\" transformation expect \"" + expectedType + "\" but got \"" + type + "\"");
        object = transformations[type][op](object, arg);
    }
    return object;
}
exports.applyTransformations = applyTransformations;
